name: Build iOS App

on:
  workflow_dispatch:
    inputs:
      build_id:
        description: 'Build ID from Supabase'
        required: true
      xcode_project_url:
        description: 'URL to download Xcode project'
        required: true
      config_url:
        description: 'URL to download config.json'
        required: true
      certificate_path:
        description: 'Path to certificate in Supabase Storage'
        required: true
      profile_path:
        description: 'Path to provisioning profile in Supabase Storage'
        required: true
      certificate_password:
        description: 'Certificate password'
        required: true
      bundle_id:
        description: 'App bundle ID'
        required: true
      version_number:
        description: 'App version number'
        required: true
      build_number:
        description: 'App build number'
        required: true

jobs:
  build:
    runs-on: macos-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Xcode project template
        run: |
          echo "Downloading template from: ${{ inputs.xcode_project_url }}"
          
          curl -L -v -o template.zip "${{ inputs.xcode_project_url }}"
          
          if [ ! -f template.zip ]; then
            echo "‚ùå template.zip was not created"
            exit 1
          fi
          
          FILE_SIZE=$(ls -lh template.zip | awk '{print $5}')
          echo "Downloaded file size: $FILE_SIZE"
          
          echo "Unzipping template..."
          unzip -q template.zip
          
          echo "Template contents:"
          ls -la
          
          # Find the ios-wrapper directory
          IOS_WRAPPER_DIR=$(find . -type d -name "ios-wrapper" | head -n 1)
          
          if [ -z "$IOS_WRAPPER_DIR" ]; then
            echo "‚ùå ios-wrapper directory not found"
            echo "Available directories:"
            find . -type d -maxdepth 3
            exit 1
          fi
          
          echo "‚úÖ Found ios-wrapper at: $IOS_WRAPPER_DIR"
          
          # Copy the entire ios-wrapper contents to root
          cp -r "$IOS_WRAPPER_DIR"/* .
          
          echo "Contents after copy:"
          ls -la
          
          # Verify both FoldaaApp directory and xcodeproj exist
          if [ ! -d "FoldaaApp" ]; then
            echo "‚ùå FoldaaApp directory not found"
            exit 1
          fi
          
          if [ ! -d "FoldaaApp.xcodeproj" ]; then
            echo "‚ùå FoldaaApp.xcodeproj not found"
            exit 1
          fi
          
          echo "‚úÖ Both FoldaaApp and FoldaaApp.xcodeproj found"
          ls -la FoldaaApp/

      - name: Download project config
        run: |
          echo "Downloading config from: ${{ inputs.config_url }}"
          curl -L -o config.json "${{ inputs.config_url }}"
          
          echo "Config downloaded"
          
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi
          
          echo "Config contents:"
          cat config.json
          
          echo "Applying configuration..."
          
          PWA_URL=$(cat config.json | jq -r '.pwaUrl')
          APP_NAME=$(cat config.json | jq -r '.appName')
          BUNDLE_ID=$(cat config.json | jq -r '.bundleId')
          VERSION=$(cat config.json | jq -r '.version')
          BUILD_NUMBER=$(cat config.json | jq -r '.buildNumber')
          
          echo "PWA URL: $PWA_URL"
          echo "App Name: $APP_NAME"
          echo "Bundle ID: $BUNDLE_ID"
          echo "Version: $VERSION"
          echo "Build Number: $BUILD_NUMBER"
          
          sed -i '' "s|{{PWA_URL}}|$PWA_URL|g" FoldaaApp/ViewController.swift
          
          sed -i '' "s|{{APP_NAME}}|$APP_NAME|g" FoldaaApp/Info.plist
          sed -i '' "s|{{BUNDLE_ID}}|$BUNDLE_ID|g" FoldaaApp/Info.plist
          sed -i '' "s|{{VERSION}}|$VERSION|g" FoldaaApp/Info.plist
          sed -i '' "s|{{BUILD_NUMBER}}|$BUILD_NUMBER|g" FoldaaApp/Info.plist
          
          echo "‚úÖ Configuration applied"
          echo "ViewController.swift size: $(ls -lh FoldaaApp/ViewController.swift | awk '{print $5}')"
          echo "Info.plist size: $(ls -lh FoldaaApp/Info.plist | awk '{print $5}')"

      - name: Download certificates
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          CERT_PATH: ${{ inputs.certificate_path }}
          PROFILE_PATH: ${{ inputs.profile_path }}
        run: |
          echo "Downloading certificate from Supabase Storage..."
          echo "Certificate path: ${CERT_PATH}"
          
          # Download using authenticated Storage API with verbose output
          HTTP_CODE=$(curl -X GET \
            "${SUPABASE_URL}/storage/v1/object/ios-certificates/${CERT_PATH}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -o cert.p12 \
            -w "%{http_code}" \
            -v)
          
          echo ""
          echo "Download HTTP Code: ${HTTP_CODE}"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Failed to download certificate (HTTP ${HTTP_CODE})"
            echo "File contents:"
            cat cert.p12
            exit 1
          fi
          
          echo "Downloading provisioning profile..."
          echo "Profile path: ${PROFILE_PATH}"
          
          curl -X GET \
            "${SUPABASE_URL}/storage/v1/object/ios-certificates/${PROFILE_PATH}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -o profile.mobileprovision
          
          echo ""
          echo "Certificate file info:"
          file cert.p12
          ls -lh cert.p12
          
          echo ""
          echo "Profile file info:"
          file profile.mobileprovision
          ls -lh profile.mobileprovision
          
          echo ""
          echo "=== üîç CHECKPOINT: Verifying certificate SHA-256 ==="
          
          # Calculate hash
          CERT_SHA256_FULL=$(shasum -a 256 cert.p12)
          CERT_SHA256=$(echo "${CERT_SHA256_FULL}" | awk '{print $1}')
          EXPECTED_SHA256="4b27540e4bf8141b1528f41bbc25f66437fd9361eead9c40014ed693164ede1a"
          
          echo "Full shasum output: ${CERT_SHA256_FULL}"
          echo "Extracted hash: ${CERT_SHA256}"
          echo "Hash length: ${#CERT_SHA256} characters"
          echo "Expected hash: ${EXPECTED_SHA256}"
          echo "Expected length: ${#EXPECTED_SHA256} characters"
          
          # Compare
          if [ "${CERT_SHA256}" = "${EXPECTED_SHA256}" ]; then
            echo "‚úÖ Certificate hash MATCHES!"
          else
            echo "‚ùå Certificate hash DOES NOT MATCH!"
            echo ""
            echo "Difference:"
            echo "Got:      ${CERT_SHA256}"
            echo "Expected: ${EXPECTED_SHA256}"
            echo ""
            echo "First 100 bytes of cert.p12:"
            xxd -l 100 cert.p12
            echo ""
            echo "Checking file type:"
            file cert.p12
            exit 1
          fi

      - name: Setup keychain
        env:
          CERT_PASSWORD: ${{ inputs.certificate_password }}
          KEYCHAIN_PASSWORD: actions
        run: |
          echo "Creating keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          
          echo "=== Certificate file verification ==="
          file cert.p12
          ls -lh cert.p12
          
          echo ""
          echo "First 32 bytes of cert.p12:"
          xxd -l 32 cert.p12
          
          if [ -z "$CERT_PASSWORD" ]; then
            echo "‚ùå ERROR: Certificate password is empty!"
            exit 1
          fi
          
          echo ""
          echo "Password length: ${#CERT_PASSWORD} characters"
          
          echo ""
          echo "=== Testing certificate with OpenSSL ==="
          
          # Use printf instead of echo to avoid adding newline
          printf '%s' "$CERT_PASSWORD" | openssl pkcs12 -in cert.p12 -noout -passin stdin
          TEST_EXIT=$?
          
          if [ $TEST_EXIT -eq 0 ]; then
            echo "‚úÖ OpenSSL can read the certificate"
          else
            echo "‚ùå OpenSSL CANNOT read certificate"
            echo "Exit code: $TEST_EXIT"
            exit 1
          fi
          
          echo ""
          echo "=== Extracting and importing certificate components ==="
          
          # Extract certificate
          echo "Extracting certificate..."
          printf '%s' "$CERT_PASSWORD" | openssl pkcs12 -in cert.p12 -clcerts -nokeys -passin stdin -out cert.pem
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to extract certificate"
            exit 1
          fi
          echo "‚úÖ Certificate extracted"
          
          # Extract private key
          echo "Extracting private key..."
          printf '%s' "$CERT_PASSWORD" | openssl pkcs12 -in cert.p12 -nocerts -nodes -passin stdin -passout pass: -out key.pem
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to extract private key"
            exit 1
          fi
          echo "‚úÖ Private key extracted"
          
          # Import certificate directly
          echo ""
          echo "Importing certificate PEM..."
          security import cert.pem \
            -k build.keychain \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -A
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to import certificate PEM"
            exit 1
          fi
          echo "‚úÖ Certificate PEM imported"
          
          # Import private key directly
          echo ""
          echo "Importing private key PEM..."
          security import key.pem \
            -k build.keychain \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -A
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to import private key PEM"
            exit 1
          fi
          echo "‚úÖ Private key PEM imported"
          
          # Cleanup PEM files
          rm -f cert.pem key.pem
          
          echo ""
          echo "Configuring keychain access..."
          security set-key-partition-list \
            -S apple-tool:,apple: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            build.keychain
          
          echo ""
          echo "Verifying certificate import:"
          security find-identity -p codesigning -v build.keychain
          
          IDENTITY_COUNT=$(security find-identity -p codesigning build.keychain | grep -c "valid identities found" || echo "0")
          if [ "$IDENTITY_COUNT" = "0" ]; then
            echo "‚ùå No valid signing identities found"
            exit 1
          fi
          
          echo ""
          echo "=== Installing and extracting provisioning profile info ==="
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          
          # Extract profile name
          echo "Extracting profile name..."
          PROFILE_NAME=$(security cms -D -i profile.mobileprovision 2>/dev/null | grep -A 1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          
          if [ -z "$PROFILE_NAME" ]; then
            echo "‚ö†Ô∏è Could not extract profile name"
            PROFILE_NAME="Unknown Profile"
          else
            echo "‚úÖ Profile Name: $PROFILE_NAME"
          fi
          
          # Extract UUID
          echo "Extracting profile UUID..."
          PROFILE_UUID=$(security cms -D -i profile.mobileprovision 2>/dev/null | grep -a "UUID" | grep -o "[-A-Z0-9]\{36\}" | head -n 1)
          
          if [ -z "$PROFILE_UUID" ]; then
            echo "‚ö†Ô∏è Could not extract profile UUID"
            echo "Installing profile without UUID..."
            cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          else
            echo "‚úÖ Profile UUID: $PROFILE_UUID"
            cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/"$PROFILE_UUID".mobileprovision
          fi
          
          # List installed profiles
          echo ""
          echo "Installed provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles found"
          
          # Export profile name for next step
          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV
          
          echo ""
          echo "‚úÖ Keychain setup complete"

      - name: Build IPA
        run: |
          echo "Building iOS app..."
          echo "Bundle ID: ${{ inputs.bundle_id }}"
          echo "Version: ${{ inputs.version_number }}"
          echo "Build: ${{ inputs.build_number }}"
          
          if [ ! -f "FoldaaApp.xcodeproj/project.pbxproj" ]; then
            echo "‚ùå FoldaaApp.xcodeproj not found"
            ls -la
            exit 1
          fi
          
          echo "Creating archive..."
          xcodebuild clean archive \
            -project FoldaaApp.xcodeproj \
            -scheme FoldaaApp \
            -configuration Release \
            -archivePath build/FoldaaApp.xcarchive \
            -allowProvisioningUpdates \
            PRODUCT_BUNDLE_IDENTIFIER="${{ inputs.bundle_id }}" \
            MARKETING_VERSION="${{ inputs.version_number }}" \
            CURRENT_PROJECT_VERSION="${{ inputs.build_number }}"
          
          echo "Creating ExportOptions.plist..."
          cat > ExportOptions.plist <<'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>5ZLA43GJ93J</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          echo "ExportOptions.plist contents:"
          cat ExportOptions.plist
          
          echo "Exporting IPA..."
          xcodebuild -exportArchive \
            -archivePath build/FoldaaApp.xcarchive \
            -exportPath build \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates
          
          echo "‚úÖ Build complete"
          ls -lh build/*.ipa

      - name: Upload to Supabase Storage
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          IPA_PATH="build/FoldaaApp.ipa"
          IPA_NAME="${{ inputs.build_id }}.ipa"
          
          echo "Uploading IPA to Supabase Storage..."
          echo "IPA path: $IPA_PATH"
          echo "IPA name: $IPA_NAME"
          
          if [ ! -f "$IPA_PATH" ]; then
            echo "‚ùå IPA file not found at $IPA_PATH"
            echo "Available files in build directory:"
            ls -la build/
            exit 1
          fi
          
          UPLOAD_RESPONSE=$(curl -X POST \
            "${SUPABASE_URL}/storage/v1/object/ios-builds/${IPA_NAME}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -H "Content-Type: application/octet-stream" \
            --data-binary "@${IPA_PATH}" \
            -w "\n%{http_code}")
          
          HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | tail -n1)
          echo "Upload HTTP code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
            echo "‚ùå Upload failed with code $HTTP_CODE"
            echo "$UPLOAD_RESPONSE"
            exit 1
          fi
          
          IPA_URL="${SUPABASE_URL}/storage/v1/object/public/ios-builds/${IPA_NAME}"
          echo "IPA uploaded to: ${IPA_URL}"
          
          echo "Updating build record..."
          UPDATE_RESPONSE=$(curl -X PATCH \
            "${SUPABASE_URL}/rest/v1/ios_builds?id=eq.${{ inputs.build_id }}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=minimal" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -d "{\"status\":\"completed\",\"ipa_url\":\"${IPA_URL}\",\"build_completed_at\":\"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\"}" \
            -w "\n%{http_code}")
          
          UPDATE_HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -n1)
          echo "Update HTTP code: $UPDATE_HTTP_CODE"
          
          if [ "$UPDATE_HTTP_CODE" != "200" ] && [ "$UPDATE_HTTP_CODE" != "204" ]; then
            echo "‚ö†Ô∏è Failed to update build record, but IPA was uploaded"
            echo "$UPDATE_RESPONSE"
          fi
          
          echo "‚úÖ Build completed successfully"

      - name: Handle failure
        if: failure()
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          echo "Build failed, updating status..."
          curl -X PATCH \
            "${SUPABASE_URL}/rest/v1/ios_builds?id=eq.${{ inputs.build_id }}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=minimal" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -d "{\"status\":\"failed\",\"error_message\":\"Build failed in GitHub Actions\",\"build_completed_at\":\"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\"}"

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          
          security delete-keychain build.keychain || true
          
          rm -f cert.p12 profile.mobileprovision || true
          
          echo "‚úÖ Cleanup complete"
